import { describe, it, expect } from 'vitest';
import { createEmitterTestRunner, readOperationFile } from './utils.jsx';

describe('Emitter Integration', () => {
  it('should compile TypeSpec without errors and generate operation files', async () => {
    const runner = await createEmitterTestRunner();
    
    // Basic compilation test - just verify the emitter works
    await runner.compile(`
      model Pet {
        id: int32;
        name: string;
        tag?: string;
        status: "available" | "pending" | "sold";
      }

      @route("/pets")
      interface Pets {
        @get
        getPet(@path petId: int32): Pet;
        
        @post
        createPet(@body pet: Pet): Pet;
        
        @delete
        deletePet(@path petId: int32): void;
      }
    `);

    // Verify that files were generated by trying to read them
    const getPetContent = await readOperationFile(runner, 'getPet');
    expect(getPetContent.length).toBeGreaterThan(0);
    
    const createPetContent = await readOperationFile(runner, 'createPet');
    expect(createPetContent.length).toBeGreaterThan(0);
    
    const deletePetContent = await readOperationFile(runner, 'deletePet');
    expect(deletePetContent.length).toBeGreaterThan(0);
  });

  it('should handle complex TypeSpec scenarios without compilation errors', async () => {
    const runner = await createEmitterTestRunner();
    
    // Test with more complex features and different routes
    await runner.compile(`
      model Address {
        street: string;
        city: string;
        zipCode?: string;
      }

      model Owner {
        name: string;
        email: string;
        address: Address;
      }

      model PetWithOwner {
        id: int32;
        name: string;
        owner: Owner;
        status: "available" | "pending" | "sold";
      }

      @route("/pets")
      interface Pets {
        @get
        listPets(@query status?: string, @query limit?: int32): PetWithOwner[];
        
        @post
        createPetWithOwner(@body petData: PetWithOwner): PetWithOwner;
      }
      
      @route("/pets/search")
      interface PetSearch {
        @get
        searchPets(
          @query q: string,
          @query category?: string,
          @header authorization: string
        ): PetWithOwner[];
      }
    `);

    // Verify that files were generated
    const listPetsContent = await readOperationFile(runner, 'listPets');
    expect(listPetsContent.length).toBeGreaterThan(0);
    
    const createContent = await readOperationFile(runner, 'createPetWithOwner');
    expect(createContent.length).toBeGreaterThan(0);
    
    const searchContent = await readOperationFile(runner, 'searchPets');
    expect(searchContent.length).toBeGreaterThan(0);
  });

  it('should handle union types and void returns correctly', async () => {
    const runner = await createEmitterTestRunner();
    
    // Test union types and void returns
    await runner.compile(`
      model Pet {
        id: int32;
        name: string;
        type: "dog" | "cat" | "bird" | "fish";
      }

      model NotFoundError {
        message: "Pet not found";
        code: 404;
      }

      @route("/pets")
      interface Pets {
        @get
        getPet(@path petId: int32): Pet | NotFoundError;
        
        @delete
        deletePet(@path petId: int32): void;
        
        @post
        resetAllPets(): void;
      }
    `);

    // Verify that files were generated
    const getPetContent = await readOperationFile(runner, 'getPet');
    expect(getPetContent.length).toBeGreaterThan(0);
    
    const deleteContent = await readOperationFile(runner, 'deletePet');
    expect(deleteContent.length).toBeGreaterThan(0);
    
    const resetContent = await readOperationFile(runner, 'resetAllPets');
    expect(resetContent.length).toBeGreaterThan(0);
  });
});